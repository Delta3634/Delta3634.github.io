

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  



  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Delta">
  <meta name="keywords" content="">
  
    <meta name="description" content="go 2025年5月14 日，正式开始学习go语言。 安装go语言、搭建开发环境看的是csdn上这篇教程 同时在看的还有B站up主无闻的视频，笔记及视频资源可以在他的Github主页看到：[go_fundamental_programming](unknwon&#x2F;go-fundamental-programming: 《Go 编程基础》是一套针对 Google 出品的 Go 语言的视频语音教程，主">
<meta property="og:type" content="article">
<meta property="og:title" content="go_beginning_250514">
<meta property="og:url" content="http://example.com/2025/05/14/go-beginning-250514/index.html">
<meta property="og:site_name" content="Delta">
<meta property="og:description" content="go 2025年5月14 日，正式开始学习go语言。 安装go语言、搭建开发环境看的是csdn上这篇教程 同时在看的还有B站up主无闻的视频，笔记及视频资源可以在他的Github主页看到：[go_fundamental_programming](unknwon&#x2F;go-fundamental-programming: 《Go 编程基础》是一套针对 Google 出品的 Go 语言的视频语音教程，主">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2025/05/14/go-beginning-250514/1.png">
<meta property="og:image" content="http://example.com/2025/05/14/go-beginning-250514/2.png">
<meta property="og:image" content="http://example.com/2025/05/14/go-beginning-250514/3.png">
<meta property="og:image" content="http://example.com/2025/05/14/go-beginning-250514/4.png">
<meta property="og:image" content="http://example.com/2025/05/14/go-beginning-250514/5.png">
<meta property="og:image" content="http://example.com/2025/05/14/go-beginning-250514/6.png">
<meta property="og:image" content="http://example.com/2025/05/14/go-beginning-250514/7.png">
<meta property="article:published_time" content="2025-05-14T03:06:03.000Z">
<meta property="article:modified_time" content="2025-05-24T13:19:44.880Z">
<meta property="article:author" content="Delta">
<meta property="article:tag" content="go">
<meta property="article:tag" content="language">
<meta property="article:tag" content="note">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2025/05/14/go-beginning-250514/1.png">
  
  
  
  <title>go_beginning_250514 - Delta</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/glassBg.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"Ege3qtslvoDkxjoOcgWTIfK4-gzGzoHsz","app_key":"XQm2hjsW66138F3PNUPluimQ","server_url":"https://ege3qtsl.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<script type="text/javascript">
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']]
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  };
</script>
<script type="text/javascript"
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>


<body><!-- hexo injector body_begin start --><div id="web_bg"></div><!-- hexo injector body_begin end -->
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Delta</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="go_beginning_250514"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-05-14 11:06" pubdate>
          2025年5月14日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          8.5k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          71 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">go_beginning_250514</h1>
            
              <p id="updated-time" class="note note-info" style="display: none">
                
                  
                    本文最后更新于 2025-05-24T21:19:44+08:00
                  
                  

                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="go"><a class="markdownIt-Anchor" href="#go"></a> <code>go</code></h1>
<p>2025年5月14 日，正式开始学习go语言。</p>
<p>安装go语言、搭建开发环境看的是csdn上这篇<a href="%5B%E5%AE%89%E8%A3%85Go%E8%AF%AD%E8%A8%80%E3%80%81%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E3%80%81%E4%BE%9D%E8%B5%96%E5%8C%85%E4%B8%8B%E8%BD%BD%EF%BC%88%E4%BF%9D%E5%A7%86%E6%95%99%E7%A8%8B%EF%BC%89_go%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/qq_38105536/article/details/142635132)">教程</a></p>
<p>同时在看的还有B站up主无闻的视频，笔记及视频资源可以在他的Github主页看到：[go_fundamental_programming](<a target="_blank" rel="noopener" href="https://github.com/unknwon/go-fundamental-programming">unknwon/go-fundamental-programming: 《Go 编程基础》是一套针对 Google 出品的 Go 语言的视频语音教程，主要面向新手级别的学习者。</a>)</p>
<h2 id="梦开始的地方"><a class="markdownIt-Anchor" href="#梦开始的地方"></a> <strong>梦开始的地方：</strong></h2>
<img src="/2025/05/14/go-beginning-250514/1.png" srcset="/img/loading.gif" lazyload class="">
<p>查看GOPATH路径的结果：</p>
<img src="/2025/05/14/go-beginning-250514/2.png" srcset="/img/loading.gif" lazyload class="">
<p>进行到Go语言开发工具包时遇到的问题：</p>
<p>未出现全选的选项，但一段时间之后终端出现了如下显示：</p>
<img src="/2025/05/14/go-beginning-250514/3.png" srcset="/img/loading.gif" lazyload class="">
<p>新建一个<code>go_projects</code>的文件夹，在vscode中打开此文件夹，切换终端为<code>cmd</code></p>
<p>使用下列语句新建<strong>属于<code>go</code>的<code>hello</code>文件</strong>：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">go mod init gohello<br></code></pre></td></tr></table></figure>
<p>之后<strong>新建<code>main.go</code>文件</strong>，并输入下列代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main <span class="hljs-comment">//导入main包，表明当前是一个可执行程序</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span> <span class="hljs-comment">//导入内置fmt包</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//main函数，是程序执行的入口</span><br>	fmt.Println(<span class="hljs-string">&quot;Go Hello !&quot;</span>) <span class="hljs-comment">// 在终端打印Go Hello !</span><br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/2025/05/14/go-beginning-250514/4.png" srcset="/img/loading.gif" lazyload class="">
<p>在终端运行<code>main.go</code>程序，便可得到<code>Go Hello !</code>的输出：</p>
<img src="/2025/05/14/go-beginning-250514/5.png" srcset="/img/loading.gif" lazyload class="">
<p><code>go build</code>编译，运行程序</p>
<p>在终端依次输入下列指令：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">go build ##进行编译,之后会生成gohello.exe文件<br><br>gohello.exe ##便可以得到Go Hello!的输出<br></code></pre></td></tr></table></figure>
<img src="/2025/05/14/go-beginning-250514/6.png" srcset="/img/loading.gif" lazyload class="">
<h2 id="2025519重新配置环境变量那些"><a class="markdownIt-Anchor" href="#2025519重新配置环境变量那些"></a> 2025.5.19重新配置环境变量那些</h2>
<p>今天在看学习文档，发现环境变量这个不得不配，而且编辑器貌似也是需要重新选择一下。所以在<code>CSDN</code>中找了一篇教程来学：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaohuihui1400/article/details/130338023?ops_request_misc=%7B%22request%5Fid%22%3A%22ae35a4f271fb388c070c6e26459944e1%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=ae35a4f271fb388c070c6e26459944e1&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-130338023-null-null.142%5Ev102%5Epc_search_result_base7&amp;utm_term=go%E7%BC%96%E8%BE%91%E5%99%A8&amp;spm=1018.2226.3001.4187">Go 环境配置、编辑器安装、第一个HelloWorld_go 1.21.0.window-amd64.msi下载-CSDN博客</a></p>
<p>–这篇用的是<code>vscode</code>和<code>Golang</code>。我在这里重新理解了一下<strong>go文件的保存路径</strong>，进一步配置了环境，并重新编写了第一个<code>Hello world!</code>的go程序。</p>
<h2 id="使用go_tour进行学习"><a class="markdownIt-Anchor" href="#使用go_tour进行学习"></a> 使用<code>Go_tour</code>进行学习</h2>
<p>第一行<code>Hello World!</code>：</p>
<p>目前还没学过任何语法，只是早上的HelloGo的模糊记忆，写了几回都报错，最后终于成功…</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main <span class="hljs-comment">//声明这是一个可执行程序</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span> <span class="hljs-comment">//导入fmt（格式化输入输出包）</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello World!&quot;</span>) <span class="hljs-comment">//输出</span><br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/2025/05/14/go-beginning-250514/7.png" srcset="/img/loading.gif" lazyload class="">
<h4 id="基本的输出语法"><a class="markdownIt-Anchor" href="#基本的输出语法"></a> 基本的输出语法</h4>
<p>（主要来自 <code>fmt</code> 包）</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能简介</th>
<th>示例输出</th>
<th>是否格式化</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fmt.Print()</code></td>
<td>直接输出，不换行</td>
<td><code>fmt.Print(&quot;Hello&quot;)</code> → <code>Hello</code></td>
<td>❌</td>
</tr>
<tr>
<td><code>fmt.Println()</code></td>
<td>输出并自动换行（加空格）</td>
<td><code>fmt.Println(&quot;A&quot;, 1)</code> → <code>A 1\n</code></td>
<td>❌</td>
</tr>
<tr>
<td><code>fmt.Printf()</code></td>
<td>格式化输出</td>
<td><code>fmt.Printf(&quot;I am %d years old&quot;, 18)</code> → <code>I am 18 years old</code></td>
<td>✅</td>
</tr>
<tr>
<td><code>fmt.Sprint()</code></td>
<td>返回字符串，不打印</td>
<td><code>s := fmt.Sprint(&quot;A&quot;, 1)</code> → <code>s = &quot;A1&quot;</code></td>
<td>❌</td>
</tr>
<tr>
<td><code>fmt.Sprintf()</code></td>
<td>返回格式化字符串</td>
<td><code>s := fmt.Sprintf(&quot;I am %d&quot;, 18)</code> → <code>s = &quot;I am 18&quot;</code></td>
<td>✅</td>
</tr>
</tbody>
</table>
<ul>
<li>常用格式化占位符（Printf 专用）</li>
</ul>
<table>
<thead>
<tr>
<th>占位符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%d</code></td>
<td>十进制整数（Decimal）</td>
</tr>
<tr>
<td><code>%f</code></td>
<td>浮点数（默认小数点后6位）</td>
</tr>
<tr>
<td><code>%.2f</code></td>
<td>保留两位小数</td>
</tr>
<tr>
<td><code>%s</code></td>
<td>字符串（String）</td>
</tr>
<tr>
<td><code>%t</code></td>
<td>布尔值（true/false）</td>
</tr>
<tr>
<td><code>%v</code></td>
<td>自动选择合适格式输出（万能占位符）</td>
</tr>
<tr>
<td><code>%T</code></td>
<td>输出变量的类型</td>
</tr>
<tr>
<td><code>%g</code></td>
<td>对浮点数自动使用最简方式表示（如 <code>3.0</code>→<code>3</code>）</td>
</tr>
</tbody>
</table>
<h2 id="基本结构和要素"><a class="markdownIt-Anchor" href="#基本结构和要素"></a> 基本结构和要素</h2>
<h3 id="包"><a class="markdownIt-Anchor" href="#包"></a> 包</h3>
<ul>
<li>
<p>每个Go程序都由包构成</p>
</li>
<li>
<p>程序从<code>main</code>包开始（所以<code>package main</code>）</p>
</li>
<li>
<p>每句不必使用分号做结尾</p>
<ul>
<li>但如果要将语句一行写出，则需要加分号以示分割（但不推荐这么写</li>
</ul>
</li>
<li>
<p>其他的包就<code>import</code>——多个包时更推荐<strong>分组导入</strong>（用圆括号将导入的包分成一组）并且可以<strong>按首字母进行排列</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;math/rand&quot;</span><br>    <span class="hljs-string">&quot;......&quot;</span><br>)<br></code></pre></td></tr></table></figure>
<ul>
<li>
<p>导入包=包含了该包中的所有数据代码对象</p>
</li>
<li>
<p>同一个包里的代码对象得是唯一的，避免冲突——不同包中的可以一样（可以用包名作区分）</p>
</li>
</ul>
</li>
</ul>
<h4 id="导出"><a class="markdownIt-Anchor" href="#导出"></a> 导出</h4>
<ul>
<li>只有<strong>首字母大写的标识符</strong>（变量、函数、类型等）才能被其他包访问</li>
<li>例如math包中的Pow函数是大写P开头，所以我们可以使用</li>
<li>如果改为pow（小写p），其他包就无法访问它（想象成面向对象语言中的private）</li>
<li>这种机制实现了封装，控制包的对外接口</li>
</ul>
<hr>
<p>导入包后，只可以访问<strong>该包中导出的对象</strong></p>
<blockquote>
<p>假设在包 pack1 中我们有一个变量或函数叫做 Thing（以 T 开头，所以它能够被导出），那么在当前包中导入 pack1 包，Thing 就可以像面向对象语言那样使用点标记来调用：pack1.Thing（pack1 在这里是不可以省略的）。</p>
<p>————————————————<br>
原文作者：Go 技术论坛文档：《Go 入门指南（）》<br>
转自链接：<a target="_blank" rel="noopener" href="https://learnku.com/docs/the-way-to-go/the-basic-structure-and-elements-of-the-go-program/3583">https://learnku.com/docs/the-way-to-go/the-basic-structure-and-elements-of-the-go-program/3583</a></p>
</blockquote>
<ul>
<li>导入了一个包却没有使用——》报错——》没有不必要的代码（所以删掉这个包的导入。。。</li>
</ul>
<h3 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">functionName</span><span class="hljs-params">()</span></span> <span class="hljs-comment">//最简单的函数定义格式</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">functionName_var</span><span class="hljs-params">(var1 <span class="hljs-type">int</span>,var2 <span class="hljs-type">bool</span>,var3,<span class="hljs-type">float32</span>)</span></span><span class="hljs-comment">//括号中可写入多个函数的参数，每个参数名后紧跟参数类型，用逗号分隔</span><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>需要包含<code>main函数</code></strong>，否则会报错
<ul>
<li>无参数，无返回类型</li>
</ul>
</li>
<li>若有<code>init函数</code>，先执行<code>init函数</code></li>
<li>函数体用<code>&#123;&#125;</code>括起，且**<code>&#123;</code>必须与方法的声明放在同一行**——》强制要求</li>
</ul>
<p><strong>变量</strong>：<code>var</code>，</p>
<ul>
<li>变量类型搞到变量后面</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">var</span> a <span class="hljs-type">bool</span>;<span class="hljs-comment">//初始化为false</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">int</span>;<span class="hljs-comment">//这里就被初始化为0</span><br><br></code></pre></td></tr></table></figure>
<p>虚数定义的时候不能单独地写<code>i</code>，如果是<code>5+i</code>，那也要写成<code>5+1i</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span>(<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;math/rand&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	fmt.Println(<span class="hljs-string">&quot;我最喜欢的数字是，&quot;</span>,rand.Intn(<span class="hljs-number">10</span>))<span class="hljs-comment">//这里包一个括号吧这些包起，，没得分号这些</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="流程控制语句"><a class="markdownIt-Anchor" href="#流程控制语句"></a> 流程控制语句</h2>
<h3 id="1for-循环"><a class="markdownIt-Anchor" href="#1for-循环"></a> 1.for 循环</h3>
<h4 id="1基础定义"><a class="markdownIt-Anchor" href="#1基础定义"></a> 1&gt;基础定义</h4>
<p><strong>条件依旧由三部分构成（这里的定义就用<code>:=</code>，简单，但是不用括号<code>()</code>括起，花括号还是需要的哈<code>&#123;&#125;</code>）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	sum := <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>		sum += i<br>	&#125;<br>	fmt.Println(sum)<br>&#125;<br><br><span class="hljs-comment">// result = 45 --sum of 0/1/2/3/4/5/6/7/8/9</span><br></code></pre></td></tr></table></figure>
<h4 id="2-循环语句简化"><a class="markdownIt-Anchor" href="#2-循环语句简化"></a> 2&gt; 循环语句简化</h4>
<ul>
<li>其中的初始化语句和后置语句是可选的（省略,<strong>加一个分号<code>;</code>就行</strong>）</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs GO"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	sum := <span class="hljs-number">1</span><br>	<span class="hljs-keyword">for</span> ; sum &lt; <span class="hljs-number">1000</span>; &#123;<br>		sum += sum<br>	&#125;<br>	fmt.Println(sum)<br>&#125;<br><span class="hljs-comment">// result = 1024 这里就没有初始化语句和后置于句，只有结束语句</span><br></code></pre></td></tr></table></figure>
<h4 id="3for也可以是go中的while去掉分号"><a class="markdownIt-Anchor" href="#3for也可以是go中的while去掉分号"></a> 3&gt;<code>for</code>也可以是<code>GO</code>中的<code>while</code>：去掉分号</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs GO"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	sum := <span class="hljs-number">1</span><br>	<span class="hljs-keyword">for</span> sum &lt; <span class="hljs-number">1000</span> &#123;<br>		sum += sum<br>	&#125;<br>	fmt.Println(sum)<br>&#125;<br><span class="hljs-comment">// result = 1024 这里相较于上一条省掉了;就变成了while</span><br></code></pre></td></tr></table></figure>
<h4 id="4无限循环省略循环条件"><a class="markdownIt-Anchor" href="#4无限循环省略循环条件"></a> 4&gt;无限循环：省略循环条件</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs GO"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">for</span> &#123;<br>	&#125;<br>&#125;<br><span class="hljs-comment">// result:</span><br>​ timeout running program<br></code></pre></td></tr></table></figure>
<h3 id="2if-判断"><a class="markdownIt-Anchor" href="#2if-判断"></a> 2.if 判断</h3>
<h4 id="1基础定义-2"><a class="markdownIt-Anchor" href="#1基础定义-2"></a> 1&gt;基础定义</h4>
<p><strong>表达式无须括号<code>()</code>括起，但花括号还是需要的<code>&#123;&#125;</code></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(x <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>	<span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> sqrt(-x) + <span class="hljs-string">&quot;i&quot;</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> fmt.Sprint(math.Sqrt(x))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Println(sqrt(<span class="hljs-number">2</span>), sqrt(<span class="hljs-number">-4</span>))<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h4 id="2if和简短语句"><a class="markdownIt-Anchor" href="#2if和简短语句"></a> 2&gt;if和简短语句</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs GO"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pow</span><span class="hljs-params">(x, n, lim <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br>	<span class="hljs-keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;<br>		<span class="hljs-keyword">return</span> v<br>	&#125;<br>	<span class="hljs-keyword">return</span> lim<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Println(<br>		pow(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>),<br>		pow(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">20</span>),<br>	)<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3switch语句"><a class="markdownIt-Anchor" href="#3switch语句"></a> 3.<code>switch</code>语句</h3>
<p><strong>go中的Switch自带break特性</strong></p>
<ul>
<li>无须自己添加，执行完一个对应符合的case后就会停止
<ul>
<li>执行顺序：从上到下，匹配成功则执行，执行完停止</li>
</ul>
</li>
<li>除非你加了<code>fallthrough</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> num := <span class="hljs-number">2</span>; num &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    fmt.Println(<span class="hljs-string">&quot;One&quot;</span>)<br>    <span class="hljs-keyword">fallthrough</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    fmt.Println(<span class="hljs-string">&quot;Two&quot;</span>)<br>    <span class="hljs-keyword">fallthrough</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>    fmt.Println(<span class="hljs-string">&quot;Three&quot;</span>)<br>&#125;<br><span class="hljs-comment">//输出结果为：</span><br><span class="hljs-comment">// Two </span><br><span class="hljs-comment">// Three</span><br></code></pre></td></tr></table></figure>
<ul>
<li>无条件<code>switch</code>——语句为空——》表达含义同<code>switch true</code>一致</li>
<li>也可以像<code>if</code>一样——带上初始化语句</li>
<li><code>case</code>不必为常量，也不必是整数——可以为布尔表达式（此时第一个返回True的case会被执行）等等
<ul>
<li><code>case</code>可以匹配多个值，用<code>,</code>分割</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// switch语句为空，case为布尔表达式</span><br>t := time.Now()<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> t.Hour() &lt; <span class="hljs-number">12</span>:<br>    fmt.Println(<span class="hljs-string">&quot;Good morning!&quot;</span>)<br><span class="hljs-keyword">case</span> t.Hour() &lt; <span class="hljs-number">18</span>:<br>    fmt.Println(<span class="hljs-string">&quot;Good afternoon.&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>    fmt.Println(<span class="hljs-string">&quot;Good evening.&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// switch带上初始化语句</span><br><span class="hljs-keyword">switch</span> x := getValue(); x &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    fmt.Println(<span class="hljs-string">&quot;One&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>    fmt.Println(<span class="hljs-string">&quot;Other&quot;</span>)<br>&#125;<br><br><br><span class="hljs-comment">// case使用多个值</span><br>day := <span class="hljs-string">&quot;Saturday&quot;</span><br><span class="hljs-keyword">switch</span> day &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Saturday&quot;</span>, <span class="hljs-string">&quot;Sunday&quot;</span>:<br>    fmt.Println(<span class="hljs-string">&quot;Weekend&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>    fmt.Println(<span class="hljs-string">&quot;Weekday&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4defer推迟"><a class="markdownIt-Anchor" href="#4defer推迟"></a> 4.<code>defer</code>推迟</h3>
<p>作用：将函数<strong>推迟到外层函数返回之后执行</strong></p>
<p>——》推迟调用的函数其参数会<strong>立即求值</strong>，但直到外层函数返回前该函数都不会被调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;world&quot;</span>)<br><br>	fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 输出为:</span><br><span class="hljs-comment">// hello </span><br><span class="hljs-comment">// world</span><br></code></pre></td></tr></table></figure>
<p>推迟调用的函数调用会被压入一个栈中。</p>
<p>——》当外层函数返回式，被推迟的调用按照<strong>后进先出的顺序调用</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;counting&quot;</span>)<br><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>		<span class="hljs-keyword">defer</span> fmt.Println(i)<br>	&#125;<br><br>	fmt.Println(<span class="hljs-string">&quot;done&quot;</span>)<br>&#125;<br><span class="hljs-comment">// result:</span><br><span class="hljs-comment">// counting</span><br><span class="hljs-comment">//done</span><br><span class="hljs-comment">//9</span><br><span class="hljs-comment">//8</span><br><span class="hljs-comment">//7</span><br><span class="hljs-comment">//6</span><br><span class="hljs-comment">//5</span><br><span class="hljs-comment">//4</span><br><span class="hljs-comment">//3</span><br><span class="hljs-comment">//2</span><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure>
<h2 id="结构体-切片-映射"><a class="markdownIt-Anchor" href="#结构体-切片-映射"></a> 结构体、切片、映射</h2>
<h3 id="1指针"><a class="markdownIt-Anchor" href="#1指针"></a> 1.指针</h3>
<h4 id="1定义"><a class="markdownIt-Anchor" href="#1定义"></a> 1&gt;定义</h4>
<p>一种变量，用来保存另一个变量的内存地址</p>
<h4 id="2定义指针与使用"><a class="markdownIt-Anchor" href="#2定义指针与使用"></a> 2&gt;定义指针与使用</h4>
<ul>
<li>
<p>定义指针变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">var</span> p *<span class="hljs-type">int</span>; <span class="hljs-comment">//这里就定义了p为一个指向int的指针</span><br>            <span class="hljs-comment">//目前未指向任何实际的内存地址，所以现在p还是空指针（nil）</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>获取变量地址</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Go">i := <span class="hljs-number">42</span><br>p = &amp;i <span class="hljs-comment">//获取变量i的地址，赋值给p</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>&amp;i</code>：取变量i的地址</li>
<li>目前：<code>p</code>保存的是<code>i</code>的内存地址</li>
</ul>
</li>
<li>
<p>访问指针指向的值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Go">fmt.Println(*p)  <span class="hljs-comment">//输出42（即i的值）</span><br>*p = <span class="hljs-number">21</span> <span class="hljs-comment">//修改指针p指向的值，相当于修改i</span><br><span class="hljs-comment">//再输出i，会发现i目前的值也为21</span><br>fmt.Println(i)<br></code></pre></td></tr></table></figure>
<ul>
<li><code>*p</code>就是<code>p所指向的值</code>，又叫<strong>解引用</strong>/简介引用</li>
<li>修改<code>*p</code>就是修改<code>i</code></li>
</ul>
</li>
</ul>
<h3 id="2结构体"><a class="markdownIt-Anchor" href="#2结构体"></a> 2.结构体</h3>
<h4 id="1定义-2"><a class="markdownIt-Anchor" href="#1定义-2"></a> 1&gt;定义</h4>
<p>一个结构体（struct）为一组字段（Field）</p>
<h4 id="2访问方式"><a class="markdownIt-Anchor" href="#2访问方式"></a> 2&gt;访问方式</h4>
<p>结构体字段可通过点号 <code>.</code> 来访问。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>	X <span class="hljs-type">int</span><br>	Y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	v := Vertex&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>	v.X = <span class="hljs-number">4</span><br>	fmt.Println(v.X)<br>&#125;<br><span class="hljs-comment">// result: 4</span><br><span class="hljs-comment">//利用.号访问了原先struct中的X，并修改其值为4</span><br></code></pre></td></tr></table></figure>
<h4 id="3结构体指针"><a class="markdownIt-Anchor" href="#3结构体指针"></a> 3&gt;结构体指针</h4>
<p>结构体字段可通过<strong>结构体指针来访问</strong>。</p>
<p>如果我们有一个指向结构体的指针 <code>p</code> 那么可以通过 <code>(*p).X</code> 来访问其字段 <code>X</code>。</p>
<p>允许我们使用<strong>隐式解引用</strong>，直接写 <code>p.X</code> 就可以。</p>
<h4 id="4结构体字面量"><a class="markdownIt-Anchor" href="#4结构体字面量"></a> 4&gt;结构体字面量</h4>
<p>给出<code>name:类型</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>	X, Y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> (<br>	v1 = Vertex&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;  <span class="hljs-comment">// 创建一个 Vertex 类型的结构体</span><br>	v2 = Vertex&#123;X: <span class="hljs-number">1</span>&#125;  <span class="hljs-comment">// Y:0 被隐式地赋予零值</span><br>	v3 = Vertex&#123;&#125;      <span class="hljs-comment">// X:0 Y:0</span><br>	p  = &amp;Vertex&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125; <span class="hljs-comment">// 创建一个 *Vertex 类型的结构体（指针）</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Println(v1, p, v2, v3)<br>&#125;<br><span class="hljs-comment">// &#123;1 2&#125; &amp;&#123;1 2&#125; &#123;1 0&#125; &#123;0 0&#125;</span><br></code></pre></td></tr></table></figure>
<h3 id="3数组"><a class="markdownIt-Anchor" href="#3数组"></a> 3.数组</h3>
<h4 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h4>
<p><code>[n]T</code>表示一个拥有n个T类型的值——长度n为其类型的一部分，so<strong>go的数组不能改变大小</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">var</span> a [<span class="hljs-number">10</span>]<span class="hljs-type">int</span> <span class="hljs-comment">//a为拥有10个整数的数组</span><br></code></pre></td></tr></table></figure>
<h4 id="实际开发中多使用切片slice动态长度是引用类型而非数组固定容器"><a class="markdownIt-Anchor" href="#实际开发中多使用切片slice动态长度是引用类型而非数组固定容器"></a> 实际开发中多使用<code>切片(slice)</code>（动态长度，是引用类型），而非数组（固定容器）</h4>
<h3 id="4切片"><a class="markdownIt-Anchor" href="#4切片"></a> 4.切片</h3>
<h4 id="1定义-3"><a class="markdownIt-Anchor" href="#1定义-3"></a> 1&gt;定义</h4>
<p><code>[]T</code>：元素类型为T的切片</p>
<p><code>a[low:high]</code>：通过两个下标来界定上界和上界——》选出一个半壁搬开区间（<strong>包括下界，不包括上界</strong>）</p>
<h4 id="2切片类似于数组的引用"><a class="markdownIt-Anchor" href="#2切片类似于数组的引用"></a> 2&gt;切片类似于数组的引用</h4>
<p>切片就像数组的引用</p>
<p>——》切片并不存储任何数据，它只是描述了底层数组中的一段。</p>
<p><strong>更改切片的元素会修改其底层数组中对应的元素</strong>。</p>
<p>和它共享底层数组的切片都会观测到这些修改。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	names := [<span class="hljs-number">4</span>]<span class="hljs-type">string</span>&#123;<br>		<span class="hljs-string">&quot;John&quot;</span>,<br>		<span class="hljs-string">&quot;Paul&quot;</span>,<br>		<span class="hljs-string">&quot;George&quot;</span>,<br>		<span class="hljs-string">&quot;Ringo&quot;</span>,<br>	&#125;<br>	fmt.Println(names)<br><br>	a := names[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]<br>	b := names[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br>	fmt.Println(a, b)<br><br>	b[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;XXX&quot;</span><br>	fmt.Println(a, b)<br>	fmt.Println(names)<br>&#125;<br><span class="hljs-comment">//输出：</span><br><span class="hljs-comment">// [John Paul George Ringo]</span><br><span class="hljs-comment">// [John Paul] [Paul George]</span><br><span class="hljs-comment">// [John XXX] [XXX George]</span><br><span class="hljs-comment">// [John XXX George Ringo]</span><br></code></pre></td></tr></table></figure>
<h4 id="3切片字面量"><a class="markdownIt-Anchor" href="#3切片字面量"></a> 3&gt;切片字面量</h4>
<p>类似于没有长度的数组字面量</p>
<ul>
<li>数组字面量： <code>[3]bool&#123;true,true,false&#125;</code></li>
<li>切片字面量：<code>[]bool&#123;true,true,false&#125;</code>
<ul>
<li>这样其实是先构建了一个[3]bool的底层数组，再构造一个指向这个数组，长度和容量均为3的切片</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>对比点</th>
<th><code>[3]bool&#123;...&#125;</code> 数组字面量</th>
<th><code>[]bool&#123;...&#125;</code> 切片字面量</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td><code>[3]bool</code></td>
<td><code>[]bool</code></td>
</tr>
<tr>
<td>内存</td>
<td>存储数据本体</td>
<td>存储对数组的引用</td>
</tr>
<tr>
<td>拷贝行为</td>
<td>复制整个数组</td>
<td>复制引用，底层数据共享</td>
</tr>
<tr>
<td>可变长度</td>
<td>❌ 固定长度</td>
<td>✅ 可动态增长（<code>append</code>）</td>
</tr>
<tr>
<td>常用吗？</td>
<td>不太常用</td>
<td>非常常用</td>
</tr>
</tbody>
</table>
<h4 id="4切片的默认行为"><a class="markdownIt-Anchor" href="#4切片的默认行为"></a> 4&gt;切片的默认行为</h4>
<p>上下界有默认行为：</p>
<ul>
<li>下界：0</li>
<li>上界：切片的长度</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">var</span> a [<span class="hljs-number">10</span>]<span class="hljs-type">int</span><br><br>a[<span class="hljs-number">0</span>:<span class="hljs-number">10</span>]<br>a[:<span class="hljs-number">10</span>]<br>a[<span class="hljs-number">0</span>:]<br>a[:] 四者等价<br></code></pre></td></tr></table></figure>
<h4 id="长度容量"><a class="markdownIt-Anchor" href="#长度容量"></a> 长度&amp;容量</h4>
<ul>
<li><strong>长度</strong>：现在切片所包含的元素个数——》<strong><code>len()</code></strong></li>
<li><strong>容量</strong>：现在切片在底层数组中对应的起始位置到末尾所包含的元素个数（可扩展的长度）——》<strong><code>cap()</code></strong></li>
<li><strong>当扩展切片到容量不够时，Go会自动创建一个新数组，并将旧内容复制进去</strong></li>
</ul>
<table>
<thead>
<tr>
<th>内容</th>
<th><code>len(slice)</code></th>
<th><code>cap(slice)</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>含义</td>
<td>当前可以访问的元素数量</td>
<td>从开始位置到底层数组末尾的空间</td>
</tr>
<tr>
<td>可变性</td>
<td>可变（<code>append</code> 可增加）</td>
<td>固定（除非分配新数组）</td>
</tr>
<tr>
<td>影响性能</td>
<td>无</td>
<td>决定是否需要重新分配内存</td>
</tr>
<tr>
<td>获取方式</td>
<td><code>len(s)</code></td>
<td><code>cap(s)</code></td>
</tr>
</tbody>
</table>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	s := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>&#125;<br>	printSlice(s)<br><br>	<span class="hljs-comment">// 截取切片使其长度为 0</span><br>	s = s[:<span class="hljs-number">0</span>]<br>	printSlice(s)<br><br>	<span class="hljs-comment">// 扩展其长度</span><br>	s = s[:<span class="hljs-number">4</span>]<br>	printSlice(s)<br><br>	<span class="hljs-comment">// 舍弃前两个值</span><br>	s = s[<span class="hljs-number">2</span>:]<br>	printSlice(s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printSlice</span><span class="hljs-params">(s []<span class="hljs-type">int</span>)</span></span> &#123;<br>	fmt.Printf(<span class="hljs-string">&quot;len=%d cap=%d %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br>&#125;<br><span class="hljs-comment">// result:</span><br><span class="hljs-comment">// len=6 cap=6 [2 3 5 7 11 13]</span><br><span class="hljs-comment">// len=0 cap=6 []</span><br><span class="hljs-comment">// len=4 cap=6 [2 3 5 7]</span><br><span class="hljs-comment">// len=2 cap=4 [5 7]</span><br></code></pre></td></tr></table></figure>
<h4 id="5nil切片"><a class="markdownIt-Anchor" href="#5nil切片"></a> 5&gt;<code>nil</code>切片</h4>
<p>切片的零值是 <code>nil</code>。</p>
<p>nil 切片的长度和容量为 0 且没有底层数组。</p>
<h4 id="6用make创建切片"><a class="markdownIt-Anchor" href="#6用make创建切片"></a> 6&gt;用<code>make</code>创建切片</h4>
<p>切片可以用内置<strong>函数 <code>make</code> <strong>来创建，这也是你</strong>创建动态数组的方式</strong>。</p>
<p><code>make</code> 函数会<strong>分配一个元素为零值的数组并返回一个引用了它的切片</strong>，这里会同步返回切片长度：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment">// len(a)=5</span><br></code></pre></td></tr></table></figure>
<p>要指定它的容量，需向 <code>make</code> 传入第三个参数：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">b</span> := <span class="hljs-built_in">make</span>(<span class="hljs-selector-attr">[]</span>int, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// len(b)=0, cap(b)=5</span><br><br><span class="hljs-selector-tag">b</span> = <span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[:cap(b)]</span> <span class="hljs-comment">// len(b)=5, cap(b)=5</span><br><span class="hljs-selector-tag">b</span> = <span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[1:]</span>      <span class="hljs-comment">// len(b)=4, cap(b)=4</span><br></code></pre></td></tr></table></figure>
<h4 id="7切片的切片"><a class="markdownIt-Anchor" href="#7切片的切片"></a> 7&gt;切片的切片</h4>
<p>切片可以包含任何类型，也可以包含其他切片</p>
<h4 id="8向切片追加元素"><a class="markdownIt-Anchor" href="#8向切片追加元素"></a> 8&gt;向切片追加元素</h4>
<p>**<code>append</code>**函数：</p>
<ul>
<li>第一个参数<code>s</code>：元素类型为T的切片，其余类型为T的元素会追加到该切片的末尾</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">append</span><span class="hljs-params">(s []T, vs ...T)</span></span> []T<br></code></pre></td></tr></table></figure>
<ul>
<li>输出的结果为：一个包含元切片所有元素加上新添加元素的切片</li>
</ul>
<p>——》当<code>s</code>的底层数组太小，不足以容纳给定的值时，他会分配一个更大的数组——》返回的切片会指向这个新分配的数组</p>
<h4 id="9-range遍历"><a class="markdownIt-Anchor" href="#9-range遍历"></a> 9&gt; <code>range</code>遍历</h4>
<p><strong><code>for</code>循环的<code>range</code>形式可以遍历切片或映射</strong></p>
<blockquote>
<p>当使用 <code>for</code> 循环遍历切片时，每次迭代都会返回两个值。 第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Go">nums := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>&#125;<br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> nums &#123;<br>    fmt.Println(<span class="hljs-string">&quot;索引:&quot;</span>, i, <span class="hljs-string">&quot;值:&quot;</span>, v)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>
<p>i 是索引（index）</p>
</li>
<li>
<p>v 是值（value）</p>
</li>
</ul>
<p>如果你只需要值，不要索引，可以用 _ 忽略：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>    fmt.Println(<span class="hljs-string">&quot;值:&quot;</span>, v)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>只需要索引，不需要值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">for</span> i,_ := <span class="hljs-keyword">range</span> nums &#123;<br>    fmt.Println(<span class="hljs-string">&quot;索引:&quot;</span>,i)<br>&#125;<br><br><span class="hljs-comment">// 也可以</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> nums &#123;<br>    fmt.Println(<span class="hljs-string">&quot;index&quot;</span>,i)<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>可以将下标或值赋予 <code>_</code> 来忽略它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> pow<br><span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> pow<br></code></pre></td></tr></table></figure>
<p>若你只需要索引，忽略第二个变量即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> pow<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="5map映射"><a class="markdownIt-Anchor" href="#5map映射"></a> 5.<code>map</code>映射</h3>
<h4 id="1定义-4"><a class="markdownIt-Anchor" href="#1定义-4"></a> 1&gt;定义</h4>
<ul>
<li>
<p><code>map[KeyType]ValueType</code>——将键映射到值</p>
</li>
<li>
<p>映射的零值为<code>nil</code>；该映射既没有键，也不能添加键</p>
</li>
<li>
<p><code>make</code>函数会返回给定类型的映射，将其初始化备用</p>
</li>
</ul>
<p>访问某个 key 的 value：<code>m[&quot;Google&quot;]</code></p>
<p>修改某个 key 的 value：<code>m[&quot;Google&quot;] = Vertex&#123;...&#125;</code></p>
<p>删除某个 key：<code>delete(m, &quot;Google&quot;)</code></p>
<p>判断 key 是否存在：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">val</span>, ok <span class="hljs-operator">:=</span> m[<span class="hljs-string">&quot;Google&quot;</span>]<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">ok</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;存在:&quot;</span>, <span class="hljs-keyword">val</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2映射字面值"><a class="markdownIt-Anchor" href="#2映射字面值"></a> 2&gt;映射字面值</h4>
<p>与结构体字面量类似，<strong>但必须要有键名</strong></p>
<h4 id="3修改映射"><a class="markdownIt-Anchor" href="#3修改映射"></a> 3&gt;修改映射</h4>
<ul>
<li>
<p>插入或修改元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Go">m[key] = elem<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>含义</strong>：向 map <code>m</code> 中插入一个键为 <code>key</code>、值为 <code>elem</code> 的元素。</li>
<li><strong>如果 key 已经存在</strong>，就会修改原有的值；</li>
<li><strong>如果 key 不存在</strong>，就会新增一个键值对。</li>
</ul>
</li>
<li>
<p>获取元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Go">elem = m[key]<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>含义</strong>：从 map <code>m</code> 中取出 key 对应的值，赋值给变量 <code>elem</code>。</li>
<li>如果 <code>key</code> 存在，就返回对应的值；</li>
<li>如果 <code>key</code> 不存在，就返回<strong>该类型的零值</strong>（比如 <code>0</code>、<code>&quot;&quot;</code>、<code>false</code>、<code>nil</code> 等）。</li>
</ul>
</li>
<li>
<p>删除元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-built_in">delete</span>(m,key)<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>含义</strong>：从 map <code>m</code> 中删除 key 对应的元素（如果存在）。</li>
<li>删除不存在的 key 不会报错，Go 会静默忽略。</li>
</ul>
</li>
<li>
<p>通过<strong>双赋值</strong>检测某个键是否存在</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Go">elem,ok = m[key]<br></code></pre></td></tr></table></figure>
<ul>
<li><strong><code>ok</code> 是一个布尔值</strong>（bool）：
<ul>
<li>如果 key 在 map 中存在，则 <code>ok == true</code>，<code>elem</code> 是对应的值；</li>
<li>如果 key 不存在，则 <code>ok == false</code>，<code>elem</code> 是类型的零值（例如 int 为 <code>0</code>）。</li>
</ul>
</li>
<li>若<code>elem</code>和<code>ok</code>未声明，那就可以直接用短变量短变量声明并赋值</li>
</ul>
</li>
</ul>
<h3 id="6函数值"><a class="markdownIt-Anchor" href="#6函数值"></a> 6.函数值（！！！）</h3>
<p>函数值也可以<strong>像其他值一样传递</strong></p>
<p>也可以<strong>用作函数的参数或返回值</strong></p>
<p>就比如这一段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-comment">// 这里的函数compute直接把函数fn的值当做参数进行传参</span><br><span class="hljs-comment">// 这里的fn其实是一个函数类型的参数，传入的函数必须符合fn的声明：接收两个float64参数并返回一个float64的函数</span><br><span class="hljs-comment">// 而compute的内容：就是会用参数3,4来调用你传入的这个fn，并返回结果</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compute</span><span class="hljs-params">(fn <span class="hljs-keyword">func</span>(<span class="hljs-type">float64</span>, <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span>) <span class="hljs-type">float64</span> &#123;<br>	<span class="hljs-keyword">return</span> fn(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 这里等号右边是一个匿名函数：定义了一个没有名字的函数</span><br>    <span class="hljs-comment">// 而后将函数值赋给变量hypot</span><br>	hypot := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br>		<span class="hljs-keyword">return</span> math.Sqrt(x*x + y*y)<br>	&#125;<br>    <br>    <span class="hljs-comment">//调用hypot(5,12)</span><br>	fmt.Println(hypot(<span class="hljs-number">5</span>, <span class="hljs-number">12</span>))<br><br>    <span class="hljs-comment">// 将函数hypot传入compute，即现在的fn为hypot，所以compute调用hypot(3,4)</span><br>    <span class="hljs-comment">// 所以归根究底这里其实就是调用hypot(3,4)而已</span><br>	fmt.Println(compute(hypot))<br>    <span class="hljs-comment">// 而这里传给compute的参数就是math.Pow，也符合fn的声明，所以compute调用math.Pow(3,4)</span><br>    <span class="hljs-comment">// 所以本质上，这个调用最终返回的是math.Pow(3,4)的值</span><br>	fmt.Println(compute(math.Pow))<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="7函数闭包"><a class="markdownIt-Anchor" href="#7函数闭包"></a> 7.函数闭包</h3>
<p><strong>闭包</strong>是指：<br>
一个<strong>函数</strong>可以“记住”并访问它外部作用域（函数外面）中的变量，即使外部函数已经返回了，这个函数依然能使用那个变量。</p>
<p>换句话说，<mark>闭包是一个<strong>函数和其相关变量环境的组合体</strong></mark>。</p>
<p>具体解释</p>
<ol>
<li><strong>函数体外的变量</strong>：闭包引用了定义在它外层的变量。比如一个函数里定义了另一个函数，内层函数可以访问外层函数的变量。</li>
<li><strong>绑定变量</strong>：闭包不仅能访问这些外部变量，还能修改它们，闭包“绑定”了这些变量，变量的生命周期会被延长。</li>
<li><strong>“函数值”</strong>：闭包本质上是一个函数值，你可以像传递普通函数那样传递它，但它“带着”自己访问的外部变量。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 这个函数 adder 返回一个“闭包函数” —— func(int) int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">adder</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	sum := <span class="hljs-number">0</span> <span class="hljs-comment">// 局部变量 sum 只属于每一次 adder 调用</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-comment">// 返回的匿名函数形成一个闭包，绑定了 sum</span><br>		sum += x      <span class="hljs-comment">// 每次调用时会累加 sum</span><br>		<span class="hljs-keyword">return</span> sum    <span class="hljs-comment">// 返回当前 sum 的值</span><br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	pos, neg := adder(), adder()<br>	<span class="hljs-comment">// 这里分别调用了两次 adder()</span><br>	<span class="hljs-comment">// 所以 pos 和 neg 是两个不同的闭包，它们分别有自己的 sum 值</span><br><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>		fmt.Println(<br>			pos(i),       <span class="hljs-comment">// 正数闭包，每次加上 i</span><br>			neg(<span class="hljs-number">-2</span>*i),    <span class="hljs-comment">// 负数闭包，每次加上 -2*i</span><br>		)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>小练习——斐波那契数</strong></p>
<h4 id="练习斐波纳契闭包"><a class="markdownIt-Anchor" href="#练习斐波纳契闭包"></a> 练习：斐波纳契闭包</h4>
<blockquote>
<p>让我们用函数做些好玩的。</p>
<p>实现一个 <code>fibonacci</code> 函数，它返回一个函数（闭包），该闭包返回一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">斐波纳契数列</a> (0, 1, 1, 2, 3, 5, …)。</p>
</blockquote>
<p>要求分析：</p>
<ul>
<li>
<p>实现一个函数<code>fibonacci</code></p>
<ul>
<li>返回一个函数（即闭包）</li>
<li>这个返回的函数每次被调用的时候，返回下一个斐波那契数</li>
<li>数列为：
<ul>
<li>F(0) = 0</li>
<li>F(1) = 1</li>
<li>F(n) = F(n-1)+F(n-2)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>所以我们目前只需要记住两个变量：就<code>prev</code>和<code>curr</code></p>
<ul>
<li>初始化为0和1</li>
<li>之后的每次调用就： <code>next := prev+curr</code> <code>prev = curr</code> <code>curr = next</code></li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span>(<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-comment">// Fibonacci函数不接受传参，返回一个同样不接受参数的函数，但这个函数会返回一个int类型的函数值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><span class="hljs-type">int</span>&#123;<br>	prev,curr := <span class="hljs-number">0</span>,<span class="hljs-number">1</span><span class="hljs-comment">//先初始化</span><br>    <br>    <span class="hljs-comment">// 这里就是在调用func()，最后的返回结果是一个int类型</span><br>    <span class="hljs-comment">// 所以这里的闭包其实是func()+fibonacci函数中的局部变量prev和curr</span><br>    <span class="hljs-comment">// 返回斐波那契数的根本原因其实是调用了func()</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span>&#123;<br>		result := prev<br>		<span class="hljs-comment">// 更新prev和curr的值</span><br>		prev,curr = curr, curr+prev<br>		<span class="hljs-comment">// 返回当前的斐波那契数</span><br>		<span class="hljs-keyword">return</span> result<br>	&#125; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	f := fibonacci()<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++&#123;<br>		fmt.Println(f())<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>小练习：</p>
<ul>
<li>累加器</li>
<li>只执行一次</li>
<li>带状态的计数器</li>
</ul>
<blockquote>
<ul>
<li>[x] <strong>练习1：累加器（Accumulator）</strong></li>
</ul>
<p><strong>要求：</strong><br>
写一个函数 <code>accumulator</code>，它返回一个闭包。这个闭包接收一个整数参数，每次调用都会把传入的数累加起来，并返回当前的累加和。</p>
<p><strong>用法示例：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">acc := accumulator()<br>fmt.Println(acc(<span class="hljs-number">5</span>))  <span class="hljs-comment">// 输出：5</span><br>fmt.Println(acc(<span class="hljs-number">3</span>))  <span class="hljs-comment">// 输出：8</span><br>fmt.Println(acc(<span class="hljs-number">10</span>)) <span class="hljs-comment">// 输出：18</span><br></code></pre></td></tr></table></figure>
<ul>
<li>[ ] <strong>练习2：只执行一次（Once）</strong></li>
</ul>
<p><strong>要求：</strong><br>
写一个函数 <code>once</code>，它接收一个函数参数 <code>fn</code>（无参数无返回值），返回一个闭包。这个闭包被调用时只会执行传入的函数一次，后续调用不会再执行 <code>fn</code>。</p>
<p><strong>用法示例：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Go">f := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello, world!&quot;</span>)<br>&#125;<br>onceFunc := once(f)<br><br>onceFunc() <span class="hljs-comment">// 输出: Hello, world!</span><br>onceFunc() <span class="hljs-comment">// 不输出了</span><br>onceFunc() <span class="hljs-comment">// 依然不输出</span><br></code></pre></td></tr></table></figure>
<ul>
<li>[ ] <strong>练习3：带状态的计数器（Stateful Counter）</strong></li>
</ul>
<p><strong>要求：</strong><br>
写一个函数 <code>makeCounter</code>，它返回两个闭包函数：一个用于增加计数（+1），另一个用于读取当前计数。</p>
<p><strong>用法示例：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">inc, get := makeCounter()<br>inc()<br>inc()<br>fmt.Println(get()) <span class="hljs-comment">// 输出：2</span><br>inc()<br>fmt.Println(get()) <span class="hljs-comment">// 输出：3</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h2 id="方法和接口"><a class="markdownIt-Anchor" href="#方法和接口"></a> 方法和接口</h2>
<h3 id="1-方法"><a class="markdownIt-Anchor" href="#1-方法"></a> 1. 方法</h3>
<h4 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1&gt; 定义</h4>
<p>方法：一类带特殊的<strong>接收者</strong>参数的函数</p>
<ul>
<li>方法接收者在它自己的参数列表内，位于 <code>func</code> 关键字和方法名之间。</li>
<li>方法接收者可以是结构体也可以是非结构体</li>
</ul>
<table>
<thead>
<tr>
<th>特点</th>
<th>函数</th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义方式</td>
<td><code>func 函数名(参数)</code></td>
<td><code>func (接收者 类型) 方法名(参数)</code></td>
</tr>
<tr>
<td>是否绑定类型</td>
<td>❌ 没有</td>
<td>✅ 绑定一个类型（通常是结构体）</td>
</tr>
<tr>
<td>调用方式</td>
<td><code>函数名(参数)</code></td>
<td><code>变量.方法名(参数)</code></td>
</tr>
<tr>
<td>语法结构</td>
<td>接收者在参数列表中</td>
<td>接收者在函数名前，独立于参数</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="方法和函数的区别"><a class="markdownIt-Anchor" href="#方法和函数的区别"></a> 方法和函数的区别</h4>
<p><strong>函数</strong>：</p>
<ul>
<li>定义时：<code>func 函数名(参数列表) 返回值</code></li>
<li>调用时：<code>函数名(传入参数)</code></li>
</ul>
<p><strong>方法</strong>：</p>
<ul>
<li>定义时：<code>func (接收者名 接收者类型) 方法名(参数列表) 返回值</code></li>
<li>调用时：<code>接收者变量.方法名(传入参数)</code></li>
</ul>
<hr>
<h4 id="2-接收者为值"><a class="markdownIt-Anchor" href="#2-接收者为值"></a> 2&gt; 接收者为值</h4>
<ul>
<li>结构体</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main <br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-comment">// 定义一个结构体——包含两个float64字段X和Y</span><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>	X,Y <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-comment">// 定义一个方法——方法是一个函数，接收者是一个结构体</span><br><span class="hljs-comment">// 方法接收者就是定义的这个Vertex结构体的v </span><br><span class="hljs-comment">// 方法的名字就是Abs()</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vertex)</span></span> Abs() <span class="hljs-type">float64</span> &#123;<br>	<span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X+v.Y*v.Y)<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	v := Vertex&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br>	fmt.Print(v.Abs())<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>
<p>很重要的一点，我们只能对<strong>同一个包中</strong>定义接收者类型声明变量</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">方法可以加吗？</th>
<th style="text-align:center">条件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">自己包中定义的结构体</td>
<td style="text-align:center">✅ 可以</td>
<td style="text-align:center">类型定义和方法声明在同一包</td>
</tr>
<tr>
<td style="text-align:center">自己包中定义的新类型（如 <code>type MyInt int</code>）</td>
<td style="text-align:center">✅ 可以</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">内置类型（<code>int</code>, <code>string</code>）</td>
<td style="text-align:center">❌ 不可以</td>
<td style="text-align:center">不在你包中定义</td>
</tr>
<tr>
<td style="text-align:center">标准库类型（如 <code>time.Time</code>）</td>
<td style="text-align:center">❌ 不可以</td>
<td style="text-align:center">不在你包中定义</td>
</tr>
<tr>
<td style="text-align:center">第三方包的类型</td>
<td style="text-align:center">❌ 不可以</td>
<td style="text-align:center">不在你包中定义</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h4 id="3-接收者为指针类型"><a class="markdownIt-Anchor" href="#3-接收者为指针类型"></a> 3&gt; 接收者为指针类型</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main <br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-comment">// 定义一个结构体——只能有字面量</span><br><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>	X,Y <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-comment">// 定义一个方法——方法是一个函数，接收者是一个结构体(值)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vertex)</span></span> Abs() <span class="hljs-type">float64</span> &#123;<br>	<span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X+v.Y*v.Y)<br>&#125;<br><br><span class="hljs-comment">// 定义一个方法——方法是一个函数，接收者是一个结构体(指针)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v  *Vertex)</span></span> Scale(f <span class="hljs-type">float64</span>)&#123;<br>	v.X=v.X*f<br>	v.Y=v.Y*f<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	v := Vertex&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br>    v.Scale(<span class="hljs-number">10</span>) <span class="hljs-comment">// 调用指针接收者的方法，这会修改 v 的 X 和 Y 值</span><br><span class="hljs-comment">// 所以在下一步调用 Abs() 时，传入的是被 Scale() 修改过的 v</span><br><span class="hljs-comment">// 即 v 的值已经变成了 (30, 40)</span><br>	fmt.Print(v.Abs())<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>如果你的方法要“修改接收者本身”或接收者结构体较大，请使用指针接收者 ；</strong></p>
</li>
<li>
<p><strong>如果只是只读访问或结构体很小，可以用值接收者</strong></p>
</li>
</ul>
<h4 id="4指针重定向"><a class="markdownIt-Anchor" href="#4指针重定向"></a> 4&gt;指针重定向</h4>
<blockquote>
<p><strong>Go 语言允许你用“结构体值”调用一个“接收者是指针”的方法，背后它会自动帮你取地址。</strong><br>
这就是所谓的 <strong>指针重定向（pointer auto-dereferencing）</strong>。</p>
</blockquote>
<blockquote>
<p>我的理解：重定向，就是允许我们在调用方法时**不用考虑88在原本定义时绑定的接收者类型，用简单的变量形式或者是指针类型，Go都会自动地帮我们转换到对应的指针类型或者是简单变量类型而不至于出现调用函数时传入参数类型不匹配会出现的报错</p>
</blockquote>
<p>在调用方法时，<strong>即使接收者类型不完全匹配</strong>（比如方法定义需要指针类型，而你传的是值类型），<strong>Go 会自动帮你转换</strong>，让你不用手动加 <code>&amp;</code> 或 <code>*</code>，也不会报错。</p>
<h4 id="5-方法一般选用指针作为接收者"><a class="markdownIt-Anchor" href="#5-方法一般选用指针作为接收者"></a> 5&gt; 方法一般选用<code>指针</code>作为接收者</h4>
<table>
<thead>
<tr>
<th>使用指针接收者的理由</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>✅ 需要修改接收者</td>
<td>不用担心值拷贝导致修改无效</td>
</tr>
<tr>
<td>✅ 节省内存和性能</td>
<td>避免每次方法调用时复制大型结构体</td>
</tr>
<tr>
<td>✅ 接口一致性</td>
<td>所有方法都使用指针接收者，调用时更统一，不混乱</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>“不要混用值接收者和指针接收者”</strong> 是一种 <strong>推荐的统一性设计原则</strong>。</p>
</blockquote>
<h3 id="2接口interface"><a class="markdownIt-Anchor" href="#2接口interface"></a> 2.接口<code>interface</code></h3>
<h4 id="1定义-5"><a class="markdownIt-Anchor" href="#1定义-5"></a> 1&gt;定义</h4>
<p><strong>接口类型</strong>的定义为<strong>一组方法签名</strong>（只关心你能做什么：即方法）</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>回答</th>
</tr>
</thead>
<tbody>
<tr>
<td>Go 中的接口是什么？</td>
<td>一组方法签名，是一种“能力描述”</td>
</tr>
<tr>
<td>它和 C++ 的区别？</td>
<td>C++ 用抽象类+继承，Go 用方法匹配+自动实现</td>
</tr>
<tr>
<td>有什么用？</td>
<td>多态、灵活编程、解耦、测试、标准库</td>
</tr>
<tr>
<td>接口变量可以装什么？</td>
<td>实现了接口中所有方法的值</td>
</tr>
<tr>
<td>指针和值的区别？</td>
<td>如果方法是 <code>*T</code> 定义的，那只有 <code>*T</code> 实现了接口，不能用 <code>T</code> 直接赋值</td>
</tr>
</tbody>
</table>
<h4 id="2接口的隐式实现"><a class="markdownIt-Anchor" href="#2接口的隐式实现"></a> 2&gt;接口的隐式实现</h4>
<p>实现一个接口的方法：实现该接口中的所有方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main <br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-comment">// 这里定义了一个接口类型Abser，里面存放了一个方法签名Abs()——但没有实现方法</span><br><span class="hljs-comment">// Go中的接口是隐式实现，即谁实现了接口中的这一组方法签名，就等于谁实现了这个接口</span><br><span class="hljs-keyword">type</span> Abser <span class="hljs-keyword">interface</span>&#123;<br>	Abs() <span class="hljs-type">float64</span> <span class="hljs-comment">//方法签名</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">var</span> a Abser <span class="hljs-comment">//这里我们声明了一个接口变量——a</span><br>	f := MyFloat(-math.Sqrt2) <span class="hljs-comment">// 声明了一个类型为MyFloat的变量f</span><br>	<span class="hljs-comment">// 这里我们声明了一个类型为Vertex的变量v</span><br>	v := Vertex&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br><br>	a = f  <span class="hljs-comment">//f MyFloat实现了Abser</span><br>	a = &amp;v  <span class="hljs-comment">// 这里的赋值覆盖掉了前面的MyFloat类型的f赋值，接下来则是 *Vertex 实现了Abser</span><br><br>	<span class="hljs-comment">//a = v  //v 这里Vertex没有实现Abser</span><br><br>	fmt.Println(a,a.Abs())<span class="hljs-comment">// 这里a是接口变量本身存储的值，而此刻a存储的是&amp;v，即*Vertex类型，所以调用的Abs方法也是用*Vertex实现的 </span><br>&#125;<br><br><span class="hljs-keyword">type</span> MyFloat <span class="hljs-type">float64</span> <span class="hljs-comment">// 定义了一个类型MyFloat，底层类型是float64</span><br><br><span class="hljs-comment">// 这里我们为MyFloat类型实现了Abs方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f MyFloat)</span></span> Abs() <span class="hljs-type">float64</span>&#123;<br>	<span class="hljs-keyword">if</span> f &lt; <span class="hljs-number">0</span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>(-f)<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>(f)<br>&#125;<br><br><br><span class="hljs-comment">// 这里我们定义了一个结构体类型Vertex</span><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span>&#123;<br>	X,Y <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-comment">// 这里我们为*Vertex类型实现了Abs方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Vertex)</span></span> Abs() <span class="hljs-type">float64</span>&#123;<br>	<span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3接口值"><a class="markdownIt-Anchor" href="#3接口值"></a> 3&gt;接口值</h4>
<p>接口也可以像其他值一样传递</p>
<ul>
<li>
<p>接口值可以用作函数的参数或返回值</p>
</li>
<li>
<p>接口值看做包含<strong>值和具体类型的元组</strong>——<code>(value,type)</code></p>
</li>
<li>
<p>接口值保存了一个具体底层类型的具体值</p>
</li>
<li>
<p>接口值调用方法时会执行其底层类型的同名方法</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span>(<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;math&quot;</span><br>)<br><span class="hljs-comment">// 定义一个接口类型，其中有一个方法M()</span><br><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span>&#123;<br>	M()<br>&#125;<br><span class="hljs-comment">// 定义一个结构体类型T,里面的字面量为S</span><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;<br>	S <span class="hljs-type">string</span> <br>&#125;<br><span class="hljs-comment">// 为*T类型实现了M方法，所以*T也实现了接口I</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> M()&#123;<br>	fmt.Println(t.S)<br>&#125;<br><span class="hljs-comment">// 定义一个底层类型为float64的类型F</span><br><span class="hljs-keyword">type</span> F <span class="hljs-type">float64</span><br><span class="hljs-comment">// 为F类型实现M方法，所以F也实现了接口I</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f F)</span></span> M()&#123;<br>	fmt.Println(f)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-comment">// 声明一个接口类型的变量i</span><br>	<span class="hljs-keyword">var</span> i I<br><br>	<span class="hljs-comment">// 这里我们声明i为一个T类型实例的指针</span><br>	i = &amp;T&#123;<span class="hljs-string">&quot;hello&quot;</span>&#125; <span class="hljs-comment">// 接口值内部是 (&amp;T&#123;&quot;hello&quot;&#125;, *T)</span><br>	describe(i)<span class="hljs-comment">//描述现在的接口值i</span><br>	<span class="hljs-comment">// 调用T类型实现的接口——方法M</span><br>	i.M()<br><br>	<span class="hljs-comment">// 声明i为一个F类型实例</span><br>	i = F(math.Pi)  <span class="hljs-comment">// 接口值内部是 (F(math.Pi), F)</span><br>	describe(i)<span class="hljs-comment">//描述现在的接口值i</span><br>	i.M()<span class="hljs-comment">//调用F类型实现的接口——方法M</span><br>&#125;<br><br><span class="hljs-comment">// 描述接口值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">describe</span><span class="hljs-params">(i I)</span></span>&#123;<br>	fmt.Printf(<span class="hljs-string">&quot;(%v,%T)\n&quot;</span>,i,i)<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="5底层值为nil的接口值"><a class="markdownIt-Anchor" href="#5底层值为nil的接口值"></a> 5&gt;底层值为<code>nil</code>的接口值</h4>
<p>即便接口内的具体值为 nil，方法<strong>仍然会被 nil 接收者调用</strong>。</p>
<p>——》不会触发空指针异常</p>
<p>——》而是否会出错取决于方法内部是否<strong>正确处理了 <code>nil</code> 接收者</strong></p>
<p>————》写了处理应对<code>nil</code>的逻辑，那就正常执行</p>
<p>————》没写，那会<code>panic</code></p>
<blockquote>
<p>**<code>panic</code>**是一种运行时异常：</p>
<ul>
<li>
<p><code>panic</code>会导致程序中断执行，并按照调用栈向上传播</p>
</li>
<li>
<p>除非你用 <code>recover()</code> 捕获它，否则程序会崩溃；</p>
<p>常见的 <code>panic</code>原因有：</p>
<ul>
<li>访问了 <code>nil</code> 指针的字段或方法；</li>
<li>数组越界；</li>
<li>除以 0；</li>
<li>手动调用 <code>panic(&quot;some error&quot;)</code>。</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;<br>	M()<br>&#125;<br><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>	S <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> M() &#123;<br>    <span class="hljs-comment">// 这里添加了处理nil的逻辑，所以不会panic</span><br>	<span class="hljs-keyword">if</span> t == <span class="hljs-literal">nil</span> &#123;<br>		fmt.Println(<span class="hljs-string">&quot;&lt;nil&gt;&quot;</span>)<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	fmt.Println(t.S)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> i I<br><br>	<span class="hljs-keyword">var</span> t *T<br>	i = t<br>	describe(i)<br>	i.M()<br><br>	i = &amp;T&#123;<span class="hljs-string">&quot;hello&quot;</span>&#125;<br>	describe(i)<br>	i.M()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">describe</span><span class="hljs-params">(i I)</span></span> &#123;<br>	fmt.Printf(<span class="hljs-string">&quot;(%v, %T)\n&quot;</span>, i, i)<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h4 id="6nil接口值"><a class="markdownIt-Anchor" href="#6nil接口值"></a> 6&gt;<code>nil</code>接口值</h4>
<p><code>nil</code>接口值几部保存值也不保存具体类型</p>
<p>为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 <strong>具体</strong> 方法的类型。</p>
<h4 id="前两者区别"><a class="markdownIt-Anchor" href="#前两者区别"></a> 前两者区别</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>接口的 type</th>
<th>接口的 value</th>
<th>是否为 nil 接口值</th>
<th>是否能调用方法</th>
<th>调用方法是否 panic</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>nil 接口值</strong></td>
<td><code>nil</code></td>
<td><code>nil</code></td>
<td>✅ 是</td>
<td>❌ 无法调用</td>
<td>✅ panic（因为无类型）</td>
</tr>
<tr>
<td><strong>底层值为 nil 的接口值</strong></td>
<td>非 <code>nil</code> 类型（如 <code>*T</code>）</td>
<td><code>nil</code></td>
<td>❌ 否</td>
<td>✅ 可以调用</td>
<td>🚫 不一定 panic，取决于方法实现</td>
</tr>
</tbody>
</table>
<h4 id="7空接口"><a class="markdownIt-Anchor" href="#7空接口"></a> 7&gt;空接口</h4>
<p>指定了零个方法的接口值被称为 <strong>空接口：</strong></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">interface</span>&#123;&#125; <br></code></pre></td></tr></table></figure>
<p>空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）</p>
<p>空接口被用来处理未知类型的值。例如，<code>fmt.Print</code> 可接受类型为 <code>interface&#123;&#125;</code> 的任意数量的参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125;<br>	describe(i)<br><br>	i = <span class="hljs-number">42</span><br>	describe(i)<br><br>	i = <span class="hljs-string">&quot;hello&quot;</span><br>	describe(i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">describe</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>	fmt.Printf(<span class="hljs-string">&quot;(%v, %T)\n&quot;</span>, i, i)<br>&#125;<br><br><span class="hljs-comment">//Result:</span><br><span class="hljs-comment">//(&lt;nil&gt;, &lt;nil&gt;)</span><br><span class="hljs-comment">//(42, int)</span><br><span class="hljs-comment">//(hello, string)</span><br></code></pre></td></tr></table></figure>
<h4 id="8类型断言"><a class="markdownIt-Anchor" href="#8类型断言"></a> 8&gt;类型断言</h4>
<ul>
<li>
<p>作用：提供了访问接口值底层具体值的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs GO">t := i.(T)<br></code></pre></td></tr></table></figure>
<p>该接口断言接口值<code>i</code>保存了具体类型<code>T</code>，并将其底层类型赋予变量<code>t</code></p>
</li>
<li>
<p>若<code>i</code>未保存<code>T</code>类型的值，该语句就会触发一个<code>panic</code></p>
</li>
<li>
<p>为判断一个接口值是否保存了一个特定的类型，<strong>类型断言</strong>可以返回两个值：<strong>其底层值以及一个布尔值</strong>（报告断言是否成功）</p>
<pre class="highlight"><code class="Go’">t,ok := i.(T)

</code></pre>
</li>
</ul>
<p>​	若<code>i</code>保存了一个<code>T</code>，那其底层值为<code>T</code>，<code>ok</code>为<code>true</code></p>
<p>​	否则，<code>ok</code> 将为 <code>false</code> 而 <code>t</code> 将为 <code>T</code> 类型的零值，程序并不会产生 panic。</p>
<h4 id="9类型选择"><a class="markdownIt-Anchor" href="#9类型选择"></a> 9&gt;类型选择</h4>
<ul>
<li>
<p>定义：是一种按顺序从结果类型断言中选择分支的结构</p>
</li>
<li>
<p><strong>实现</strong>：与一般的 switch 语句相似，不过<strong>类型选择中的 case 为类型（而非值）</strong>， 它们针对给定接口值所存储的值的类型进行比较。</p>
</li>
<li>
<p><strong>声明</strong>：与类型断言 <code>i.(T)</code> 的语法相同，只是具体类型 <code>T</code> 被替换成了<strong>关键字 <code>type</code></strong>。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> v := i.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> T:<br>    <span class="hljs-comment">// v 的类型为 T</span><br><span class="hljs-keyword">case</span> S:<br>    <span class="hljs-comment">// v 的类型为 S</span><br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// 没有匹配，v 与 i 的类型相同</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>此选择语句判断接口值 <code>i</code> 保存的值类型是 <code>T</code> 还是 <code>S</code>。
<ul>
<li>在 <code>T</code> 或 <code>S</code> 的情况下，变量 <code>v</code> 会分别按 <code>T</code> 或 <code>S</code> 类型保存 <code>i</code> 拥有的值。</li>
<li>在默认（即没有匹配）的情况下，变量 <code>v</code> 与 <code>i</code> 的接口类型和值相同。</li>
</ul>
</li>
</ul>
<h4 id="9stringer"><a class="markdownIt-Anchor" href="#9stringer"></a> 9&gt;<code>Stringer</code></h4>
<p><a target="_blank" rel="noopener" href="https://go-zh.org/pkg/fmt/"><code>fmt</code></a> 包中定义的 <a target="_blank" rel="noopener" href="https://go-zh.org/pkg/fmt/#Stringer"><code>Stringer</code></a> 是最普遍的接口之一。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Stringer</span> interface &#123;<br>    <span class="hljs-type">String</span>() string<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Stringer</code> 是一个可以用字符串描述自己的类型。<code>fmt</code> 包（还有很多包）都通过此接口来打印值。</p>
<h4 id="10错误"><a class="markdownIt-Anchor" href="#10错误"></a> 10&gt;错误</h4>
<p>Go 程序使用 <code>error</code> 值来表示错误状态。</p>
<p>与 <code>fmt.Stringer</code> 类似，<code>error</code> 类型是一个内建接口：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">type <span class="hljs-built_in">error</span><span class="hljs-built_in"> interface </span>&#123;<br>    <span class="hljs-built_in">Error</span>() string<br>&#125;<br></code></pre></td></tr></table></figure>
<p>（与 <code>fmt.Stringer</code> 类似，<code>fmt</code> 包也会根据对 <code>error</code> 的实现来打印值。）</p>
<p>通常函数会返回一个 <code>error</code> 值，调用它的代码应当判断这个错误是否等于 <code>nil</code> 来进行错误处理。</p>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs hsp">i, <span class="hljs-keyword">err</span> := strconv.Atoi(<span class="hljs-string">&quot;42&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> != nil &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;couldn&#x27;t convert number: %v\n&quot;</span>, <span class="hljs-keyword">err</span>)<br>    <span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;Converted integer:&quot;</span>, i)<br></code></pre></td></tr></table></figure>
<p><code>error</code> 为 nil 时表示成功；非 nil 的 <code>error</code> 表示失败。</p>
<p>————》人工智能的算法</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/go/" class="print-no-link">#go</a>
      
        <a href="/tags/language/" class="print-no-link">#language</a>
      
        <a href="/tags/note/" class="print-no-link">#note</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>go_beginning_250514</div>
      <div>http://example.com/2025/05/14/go-beginning-250514/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Delta</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年5月14日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2025年5月24日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/05/15/%E7%AC%AC%E4%B8%80%E7%AF%87%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E6%8A%A5%E5%91%8A%E4%B9%8B%E9%98%85%E8%AF%BB%E7%BB%8F%E9%AA%8C/" title="第一篇论文阅读报告之阅读经验">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">第一篇论文阅读报告之阅读经验</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/05/02/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80/" title="前后端基础">
                        <span class="hidden-mobile">前后端基础</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"Ege3qtslvoDkxjoOcgWTIfK4-gzGzoHsz","appKey":"XQm2hjsW66138F3PNUPluimQ","path":"window.location.pathname","placeholder":"说点什么","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  

</div>

  
  
<div>
  <span id="timeDate"> 正在载入天数...</span>
  <span id="times"> 载入时分秒...</span>
  <script>
    function createtime() {
      var now = new Date(); // 每次重新获取当前时间！
      var grt = new Date("4/24/2025 11:15:00"); // 网站创建时间
      var diff = now - grt; // 相差的毫秒数

      var days = diff / (1000 * 60 * 60 * 24);
      var dnum = Math.floor(days);

      var hours = (diff / (1000 * 60 * 60)) - (24 * dnum);
      var hnum = Math.floor(hours);
      if (String(hnum).length === 1) {
        hnum = "0" + hnum;
      }

      var minutes = (diff / (1000 * 60)) - (24 * 60 * dnum) - (60 * hnum);
      var mnum = Math.floor(minutes);
      if (String(mnum).length === 1) {
        mnum = "0" + mnum;
      }

      var seconds = (diff / 1000) - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
      var snum = Math.floor(seconds);
      if (String(snum).length === 1) {
        snum = "0" + snum;
      }

      document.getElementById("timeDate").innerHTML = "🚀本网站已运行 " + dnum + " 天";
      document.getElementById("times").innerHTML = hnum + " 时 " + mnum + " 分 " + snum + " 秒";
    }
    setInterval(createtime, 1000); // 每秒更新一次就可以了
  </script>
</div>

</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  var relativeDate = function() {
    var updatedTime = document.getElementById('updated-time');
    if (updatedTime) {
      var text = updatedTime.textContent;
      var reg = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/;
      var matchs = text.match(reg);
      if (matchs) {
        var relativeTime = moment(matchs[0]).fromNow();
        updatedTime.textContent = text.replace(reg, relativeTime);
      }
      updatedTime.style.display = '';
    }
  };
  Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/moment.min.js', function() {
    if (!'zh-cn'.startsWith('en')) {
      Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/locale/zh-cn.min.js', function() {
        relativeDate();
      });
    } else {
      relativeDate();
    }
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/backgroundize.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start --><script src="/js/backgroundize.js"></script><!-- hexo injector body_end end --></body>
</html>
